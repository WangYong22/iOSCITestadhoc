pipeline {
  agent any

  environment {
    KCFG_ID     = 'k8s-jenkins'                 // kubeconfig 凭据ID
    POD_TMPL    = 'macos-pod.yaml'              // Pod 模板
    BUILD_NODE  = "macos-${env.BUILD_TAG}"      // 本次构建唯一节点名
    JENKINS_URL = 'http://17.87.2.137:8080'     // Jenkins 根URL（不要以 / 结尾）
  }

  options { timestamps() }

  stages {

    stage('Create Jenkins Node') {
      agent { label 'macmain' }   // <- 这里是装了 kubectl 的 Mac节点
      steps {
        withCredentials([usernameColonPassword(credentialsId: 'jenkins-api', variable: 'JAUTH')]) {
          script {
            def NODE = env.BUILD_NODE
            def JURL = (env.JENKINS_URL?.trim()) ?: 'http://17.87.2.137:8080'

            // 1) 写入节点 XML（注意 \$ 的转义）
            writeFile file: 'node.xml', text: """
<slave>
  <name>${NODE}</name>
  <description>ephemeral macOS</description>
  <remoteFS>/Users/test/jenkins-agent</remoteFS>
  <numExecutors>1</numExecutors>
  <mode>NORMAL</mode>
  <retentionStrategy class="hudson.slaves.RetentionStrategy\\\$Always"/>
  <launcher class="hudson.slaves.JNLPLauncher">
    <webSocket>true</webSocket>
  </launcher>
  <label>${NODE}</label>
  <nodeProperties/>
</slave>
""".stripIndent()

            // 2) 取 crumb -> /scriptText 创建/更新 -> 覆盖 config.xml -> 解析 JNLP secret（不跑 kubectl）
            sh """#!/bin/bash
set -xeuo pipefail
NODE='${NODE}'
JURL='${JURL}'

# 取 CSRF crumb
if command -v jq >/dev/null 2>&1; then
  CRUMB=\$(curl -fsS -u "\$JAUTH" "\$JURL/crumbIssuer/api/json" | jq -r .crumb)
else
  CRUMB=\$(curl -fsS -u "\$JAUTH" "\$JURL/crumbIssuer/api/json" | sed -n 's/.*"crumb"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/p')
fi
[ -n "\$CRUMB" ] || { echo "Failed to get CRUMB"; exit 1; }

# 写到临时文件，避免 read -d '' 的坑
cat > .scriptText.groovy <<GROOVY
import jenkins.model.Jenkins
import hudson.model.Node
import hudson.slaves.DumbSlave
import hudson.slaves.RetentionStrategy
import hudson.slaves.JNLPLauncher
import java.util.LinkedList

def name   = "${NODE}"            // ← 直接嵌入 bash 里的 NODE 值
def labels = name
def home   = "/Users/test/jenkins-agent"

def j = Jenkins.get()
def n = j.getNode(name)
def launcher = new JNLPLauncher()
launcher.setWebSocket(true)

if (n == null) {
  n = new DumbSlave(name, "ephemeral macOS", home, "1",
    Node.Mode.NORMAL, labels, launcher,
    new RetentionStrategy.Always(), new LinkedList())
  j.addNode(n)
} else {
  n.setLauncher(launcher)
  n.setLabelString(labels)
  n.setNumExecutors(1)
  n.setMode(Node.Mode.NORMAL)
  j.save()
}
println "READY"
GROOVY

export NODE_NAME="\$NODE"

# 执行 /scriptText
RESP=\$(curl -fsS -u "\$JAUTH" -H "Jenkins-Crumb: \$CRUMB" \\
  --data-urlencode script@.scriptText.groovy \\
  "\$JURL/scriptText")
echo "\$RESP" | grep -q READY || { echo "scriptText create node failed"; echo "\$RESP" | head -200; exit 1; }

# 覆盖节点 config.xml（幂等）
curl -fsS -u "\$JAUTH" -H "Jenkins-Crumb: \$CRUMB" \\
     -X POST -H 'Content-Type: application/xml' \\
     --data-binary @node.xml \\
     "\$JURL/computer/\$NODE/config.xml"

# 解析 JNLP secret（新旧路径兼容）
sleep 2
HTTP1=\$(curl -u "\$JAUTH" -w '%{http_code}' -fsSLo .jnlp1 "\$JURL/computer/\$NODE/jenkins-agent.jnlp" || true)
HTTP2=\$(curl -u "\$JAUTH" -w '%{http_code}' -fsSLo .jnlp2 "\$JURL/computer/\$NODE/slave-agent.jnlp"   || true)
echo "jenkins-agent.jnlp http=\$HTTP1, slave-agent.jnlp http=\$HTTP2"

SECRET=""
SECRET=\$(grep -hoE -- '--secret [0-9a-f]{64,}' .jnlp1 .jnlp2 2>/dev/null | head -1 | awk '{print \$2}') || true
if [ -z "\$SECRET" ]; then
  SECRET=\$(grep -hoE -- '<argument>[0-9a-f]{64,}</argument>' .jnlp1 .jnlp2 2>/dev/null | head -1 | sed -E 's#</?argument>##g') || true
fi
[ -n "\$SECRET" ] || { echo "no JNLP secret parsed"; head -50 .jnlp1 .jnlp2 2>/dev/null || true; exit 1; }
echo "\$SECRET" > .jnlp.secret
echo "Parsed JNLP secret length=\${#SECRET}"
"""

// 关键：从文件读回到 Groovy 变量
def SECRET = readFile('.jnlp.secret').trim()
echo "Groovy got SECRET length=${SECRET.length()}"


// 3) 现在进入 withKubeConfig，下发 K8s Secret 时，使用 Groovy 变量插值
withKubeConfig([credentialsId: env.KCFG_ID]) {
  sh """#!/bin/bash
set -xeuo pipefail
kubectl -n ci delete secret jenkins-macos-${NODE} --ignore-not-found || true
kubectl -n ci create secret generic jenkins-macos-${NODE} \\
  --from-literal=JENKINS_URL=${JURL} \
  --from-literal=JENKINS_NODE_NAME=${NODE} \
  --from-literal=JENKINS_SECRET=${SECRET}  \
  --from-literal=VM_USER=test \
  --from-literal=VM_PASS=test 
"""
            }
          }
        }
      }
    }

    stage('Launch VM Pod') {
      agent { label 'macmain' }   // <- 这里是装了 kubectl 的 Mac节点
      steps {
        sh 'cp /Users/mdsadmin/jenkins_home/pod-templates/macos-pod.yaml .'
        withKubeConfig([credentialsId: env.KCFG_ID]) {
          sh """
            sed -e "s/__BUILD_ID__/${BUILD_NODE}/g" \
                -e "s/__HOST_PORT__/30222/g"  \
                -e "s/__VZ_USER__/test/g" \
                -e "s/__VZ_PASS__/test/g" macos-pod.yaml > rendered.yaml

            echo '===== rendered.yaml (compute env) ====='
            awk '/name: compute/{f=1} f{print} /name: jenkins-bootstrap/{f=0}' rendered.yaml
            echo '======================================'

            kubectl -n ci apply -f rendered.yaml
          """
      
     //下面的内容是排查 Pod 异常   
     //     sh '''
     //       kubectl -n ci wait --for=condition=Initialized --timeout=120s pod/macos-build-${BUILD_NODE} || true

     //       kubectl -n ci describe pod macos-build-${BUILD_NODE} | sed -n '/Events:/,$p'
     //       kubectl -n ci get pod macos-build-${BUILD_NODE} -o wide || true

     //      kubectl -n ci get pod macos-build-${BUILD_NODE} -o json \
     //        | jq '.spec.containers[] | select(.name=="jenkins-bootstrap") | {envFrom: .envFrom, env: .env}' || true

     //       kubectl -n ci get secret jenkins-macos-${BUILD_NODE} -o jsonpath='{.data.JENKINS_URL}' | base64 -d; echo
     //       kubectl -n ci get secret jenkins-macos-${BUILD_NODE} -o jsonpath='{.data.JENKINS_SECRET}' | base64 -d | awk '{print "LEN=" length}'

        
     //     '''
     //     sh '''
     //       POD=macos-build-${BUILD_NODE}

     //         # 每个容器的等待原因/信息
     //       kubectl -n ci get pod "$POD" -o jsonpath='{range .status.containerStatuses[*]}{.name}{" => "}{.state.waiting.reason}{" : "}{.state.waiting.message}{"\n"}{end}' || true
     //       echo

     //          # 只看 jenkins-bootstrap 的详细等待对象
     //       kubectl -n ci get pod "$POD" -o json \
     //          | jq '.status.containerStatuses[] | select(.name=="jenkins-bootstrap")' || true

     //          # 相关事件（按时间排序）
     //        kubectl -n ci get events --field-selector involvedObject.name="$POD" --sort-by=.lastTimestamp || true
     //      '''
     //      sh '''
     //        kubectl -n ci get pod macos-build-${BUILD_NODE} -o yaml \
     //          | sed -n "/containerStatuses:/,/^$/p" || true
     //      '''
     //      sh """
     //        kubectl -n ci get pod macos-build-${BUILD_NODE} -o wide || true
     //      """
        }
      }
    }
  
	stage('Cred debug: ssh private key (137ssh)') {
	  agent { label 'macmain' }   // <- 这里是装了 kubectl 的 Mac节点
	  steps {
		withCredentials([sshUserPrivateKey(credentialsId: '137ssh',
										   keyFileVariable: 'SSH_KEY',
										   usernameVariable: 'SSH_USER')]) {
		  sh '''#!/bin/bash
			set -euo pipefail
			echo "[DEBUG] local host: $(hostname)"
			
			ssh -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			   "$SSH_USER@17.87.2.137" 'echo "[REMOTE] ok from $(hostname)"'
			'''
			}
	  }
	}


	 stage('Build on macOS') {
	  agent { label "${env.BUILD_NODE}" }
	
	  steps {
	   withCredentials([
		  string(credentialsId: 'macos-login-keychain-pass', variable: 'KEYCHAIN_PASS'),
		  string(credentialsId: 'dist-p12-pass',             variable: 'P12_PASS')
		])  {
			  sh '''#!/bin/bash
			  set -euo pipefail
			
			  LOGIN_KC="${HOME}/Library/Keychains/login.keychain-db"
			  : "${KEYCHAIN_PASS:?missing macos-login-keychain-pass}"
			  : "${P12_PASS:?missing dist-p12-pass}"
			
			  # ========= 在项目根目录自动发现 .p12 =========
			  cd "$WORKSPACE"
			  CANDS=( *.p12 )
			  if [ ! -f "${CANDS[0]}" ]; then
				echo "[ERR] no .p12 found in project root: $WORKSPACE"
				exit 2
			  fi
			  P12_PATH="${CANDS[0]}"
			  echo "[P12] picked: $P12_PATH"
			
			  # ========= 准备钥匙串 =========
			  [ -f "$LOGIN_KC" ] || security create-keychain -p "$KEYCHAIN_PASS" "$LOGIN_KC"
			  security unlock-keychain -p "$KEYCHAIN_PASS" "$LOGIN_KC"
			  security default-keychain -s "$LOGIN_KC"
			  security list-keychains -d user -s "$LOGIN_KC"
			  # 可选：避免很快上锁
			  # security set-keychain-settings -lut 3600 "$LOGIN_KC"
			
			  # ========= 导入 p12 =========
			  echo "[CERT] import $P12_PATH -> $LOGIN_KC"
			  security import "$P12_PATH" -k "$LOGIN_KC" -P "$P12_PASS" -A
			
			  # 允许 codesign/xcodebuild 无交互访问私钥
			  security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASS" "$LOGIN_KC"
			
			  echo "[CERT] codesigning identities:"
			  security find-identity -v -p codesigning || true
			  '''
			}
		
		// 1) 连通性
		sh '''#!/bin/bash
		set -euo pipefail
		hostname
		sw_vers
		'''
	
		// 2) 拉取 provisioning profile（用 Jenkins 中 ID=137ssh 的私钥）
		
		sh '''#!/bin/bash
		set -euo pipefail
		
	    echo "[CHK] A: start profile lookup"

		# ==== 可配置项 ====
		SEARCH_ROOT="${WORKSPACE:-$PWD}"
		# 注意：双引号里是一个字符串，后面会手动展开为两个模式
		PROFILE_GLOB="${PROFILE_GLOB:-*.mobileprovision *.provisionprofile}"
		PREFER_BUNDLEID="${PREFER_BUNDLEID:-}"
		echo "[DBG] SEARCH_ROOT=$SEARCH_ROOT"
		echo "[DBG] PROFILE_GLOB=$PROFILE_GLOB"
		echo "[DBG] PREFER_BUNDLEID=$PREFER_BUNDLEID"
		# =================
		
		# 收集候选（按时间倒序）
		echo "[CHK] B: collect candidates"
		CANDIDATES=()
		# 手工拆分 glob 列表，兼容 bash 3.2
		for pat in ${PROFILE_GLOB}; do
		  while IFS= read -r f; do
			[ -n "$f" ] && CANDIDATES+=("$f")
		  done < <(cd "$SEARCH_ROOT" && ls -1t $pat 2>/dev/null || true)
		done
		
		if [ ${#CANDIDATES[@]} -eq 0 ]; then
		  echo "[ERR] 未找到 *.mobileprovision / *.provisionprofile；请把 profile 放到仓库根或设置 PROFILE_GLOB"
		  exit 1
		fi
		echo "[DBG] candidates count=${#CANDIDATES[@]}"
		printf '  - %s\n' "${CANDIDATES[@]}"
		
		# 读取 profile 的 application-identifier （TEAMID.bundleid）
		read_appid() {
		  local pf="$1" tmp err
		  tmp="$(mktemp /tmp/_pp.XXXXXX.plist)"
		  err="$(mktemp /tmp/_pp.err.XXXXXX)"
		  if /usr/bin/security cms -D -i "$pf" >"$tmp" 2>"$err"; then
			:  # OK
		  else
			echo "[WARN] security cms failed on $pf:"
			cat "$err" || true
			if file "$pf" | grep -qi 'XML'; then
			  cp "$pf" "$tmp"
			else
			  rm -f "$tmp" "$err"
			  return 1
			fi
		  fi
		  APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$tmp" 2>/dev/null || echo "")
		  rm -f "$tmp" "$err"
		  [ -n "$APPID" ]
		}
		
		# 选择 profile：优先匹配 PREFER_BUNDLEID，否则取最新
		echo "[CHK] C: pick profile"
		PROFILE=""
		if [ -n "$PREFER_BUNDLEID" ]; then
		  for f in "${CANDIDATES[@]}"; do
			pf="$SEARCH_ROOT/$f"
			if read_appid "$pf"; then
			  bid="${APPID#*.}"
			  if [ "$bid" = "$PREFER_BUNDLEID" ]; then
				PROFILE="$pf"
				break
			  fi
			fi
		  done
		fi
		if [ -z "$PROFILE" ]; then
		  PROFILE="$SEARCH_ROOT/${CANDIDATES[0]}"
		fi
		echo "[PICK] $PROFILE"
		[ -f "$PROFILE" ] || { echo "[ERR] PROFILE 文件不存在：$PROFILE"; exit 1; }
		
		# 解包 plist
		echo "[CHK] D: decode profile"
		PLIST="$(mktemp /tmp/_pp.XXXXXX.plist)"
		if /usr/bin/security cms -D -i "$PROFILE" > "$PLIST" 2>/dev/null; then
		  :
		else
		  if file "$PROFILE" | grep -qi 'XML'; then
			cp "$PROFILE" "$PLIST"
		  else
			echo "[ERR] 无法解析 provisioning profile：$PROFILE"
			exit 1
		  fi
		fi
		/usr/bin/plutil -lint "$PLIST"
		
		# 取关键字段
		NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$PLIST")
		UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$PLIST")
		APPID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$PLIST" 2>/dev/null || echo "")
		TEAM_FROM_ENT=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:com.apple.developer.team-identifier' "$PLIST" 2>/dev/null || echo "")
		GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' "$PLIST" 2>/dev/null || echo "false")
		PLATFORM0=$(/usr/libexec/PlistBuddy -c 'Print :Platform:0' "$PLIST" 2>/dev/null || echo "")
		
		TEAMID="${TEAM_FROM_ENT:-${APPID%%.*}}"
		BUNDLEID="${APPID#*.}"
		
		echo "[PP] Name=$NAME"
		echo "[PP] UUID=$UUID"
		echo "[PP] TeamID=$TEAMID"
		echo "[PP] BundleID=$BUNDLEID"
		echo "[PP] get-task-allow=$GET_TASK_ALLOW"
		echo "[PP] Platform[0]=$PLATFORM0"
		
		# 判定证书类型与目的平台
                  # 读取可选键
		  PROVISIONS_ALL=$(/usr/libexec/PlistBuddy -c 'Print :ProvisionsAllDevices' "$PLIST" 2>/dev/null || echo "false")
		  if /usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' "$PLIST" >/dev/null 2>&1; then
		    HAS_DEVICES=true
		  else
		    HAS_DEVICES=false
		  fi

		  # 判定导出 method 与证书类型
		  if [ "$GET_TASK_ALLOW" = "true" ]; then
		    METHOD="development"
		  else
		    if [ "$PROVISIONS_ALL" = "true" ]; then
		      METHOD="enterprise"
 		    elif $HAS_DEVICES; then
 		      METHOD="ad-hoc"
 		    else
 		      METHOD="app-store"
  		    fi	 
		  fi

		  # 已在前文解析得到：PP_CERT_CN（从 profile 的 DeveloperCertificates 取 CN）
	  	  # 例：PP_CERT_CN="iPhone Distribution: Yong Wang (64KDUQCYEB)"
		
		  ALL_IDS="$(security find-identity -v -p codesigning 2>/dev/null || true)"
		  echo "[DBG] identities raw:"; printf '%s\n' "$ALL_IDS" | sed 's/^/  /'
		
		  # 仅按 CN 精确匹配（完全等于）
		  CODE_SIGN_IDENTITY="$(
		    printf '%s\n' "$ALL_IDS" \
		    | awk -v cn="$PP_CERT_CN" -F'"' '$2==cn {print $2; exit}'
		  )"
		
		  if [ -z "$CODE_SIGN_IDENTITY" ]; then
		    echo "[ERR] 找不到与 profile 中证书 CN 完全一致的 codesigning identity"
		    echo "      期望 CN: '$PP_CERT_CN'"
		    echo "      请确认该证书(含私钥)已导入并位于当前 login.keychain 中。"
		    exit 1
		  fi
		
		  echo "[CERT] picked identity: $CODE_SIGN_IDENTITY"
		
		
		  echo "[PP] method=$METHOD  cert=$CERT_KIND  hasDevices=$HAS_DEVICES  allDevices=$PROVISIONS_ALL"		


		# —— 不再在这里直接设置 DESTINATION；只做平台“提示” —— 
		case "$(printf '%s' "${PLATFORM0:-}" | tr '[:upper:]' '[:lower:]')" in
		  visionos|xros) DESTINATION_HINT="generic/platform=visionOS" ;;
		  ios)           DESTINATION_HINT="generic/platform=iOS" ;;
		  macos)         DESTINATION_HINT="generic/platform=macOS" ;;
		  *)             DESTINATION_HINT="" ;;
		esac
		
		echo "[PP] kind=$METHOD  platform_hint=${DESTINATION_HINT:-none}  cert=$CERT_KIND"
		
		# 安装 profile
		DEST_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
		mkdir -p "$DEST_DIR"
		install -m 0644 "$PROFILE" "$DEST_DIR/${UUID}.mobileprovision"
		echo "[INSTALL] $DEST_DIR/${UUID}.mobileprovision"
		
		# 选择匹配证书（需要你已导入带私钥证书并解锁 login 钥匙串）
		echo "[CHK] E: pick signing identity (robust matcher)"

		
			ALL_IDS="$(security find-identity -v -p codesigning 2>/dev/null || true)"
			echo "[DBG] identities raw:"
			printf '%s\n' "$ALL_IDS" | sed -e 's/^/  /'
			
			pick_by_cn() {
			  # 精确用证书可读名称匹配（CN）
			  printf '%s\n' "$ALL_IDS" | awk -v cn="$CERT_CN" -F'"' '$0 ~ cn {print $2; exit}'
			}
			
			pick_by_kind_team() {
			  # 同时匹配证书类型 + (TEAMID) —— 某些系统输出里没有(TEAMID)，可能匹配不到
			  printf '%s\n' "$ALL_IDS" | awk -v k="$CERT_KIND" -v t="$TEAMID" -F'"' \
				  'index($0,k) && index($0,"(" t ")") {print $2; exit}'
			}
			
			pick_by_kind_only() {
			  # 只匹配证书类型（如 Apple Development），取第一张
			  printf '%s\n' "$ALL_IDS" | awk -v k="$CERT_KIND" -F'"' \
				  'index($0,k) {print $2; exit}'
			}
			
			CODE_SIGN_IDENTITY=""
			
			if [ -n "${CERT_CN:-}" ]; then
			  CODE_SIGN_IDENTITY="$(pick_by_cn)"
			  echo "[DBG] pick_by_cn => ${CODE_SIGN_IDENTITY:-<empty>}"
			fi
			
			if [ -z "$CODE_SIGN_IDENTITY" ]; then
			  CODE_SIGN_IDENTITY="$(pick_by_kind_team)"
			  echo "[DBG] pick_by_kind_team => ${CODE_SIGN_IDENTITY:-<empty>}"
			fi
			
			if [ -z "$CODE_SIGN_IDENTITY" ]; then
			  CODE_SIGN_IDENTITY="$(pick_by_kind_only)"
			  echo "[DBG] pick_by_kind_only => ${CODE_SIGN_IDENTITY:-<empty>}"
			fi
			
			if [ -z "$CODE_SIGN_IDENTITY" ]; then
			  echo "[ERR] 仍然找不到匹配证书（kind=$CERT_KIND, team=$TEAMID）。"
			  echo "      你可以显式指定： export CERT_CN='Apple Development: Yong Wang (LFBT5QQQ6J)'"
			  exit 1
			fi
			
			echo "[CERT] picked: $CODE_SIGN_IDENTITY"
		
		
		# ====== 自动探测 Xcode 工程 / Scheme / Configuration ======
		set -euo pipefail
		
		# 已有值则尊重，没值才探测
		: "${WORKSPACE:=$PWD}"
		
		# 1) 找到工程路径（优先 .xcworkspace）
			Project_Path=""
			# 先当前目录
			if compgen -G "*.xcworkspace" >/dev/null; then
			  Project_Path="./$(ls -1d *.xcworkspace | head -1)"
			elif compgen -G "*.xcodeproj" >/dev/null; then
			  Project_Path="./$(ls -1d *.xcodeproj   | head -1)"
			else
			  # 再找一级子目录
			  while IFS= read -r d; do
				[ -d "$d" ] || continue
				if compgen -G "$d"*.xcworkspace >/dev/null; then
				  Project_Path="$(ls -1d "$d"*.xcworkspace | head -1)"; break
				elif compgen -G "$d"*.xcodeproj >/dev/null; then
				  Project_Path="$(ls -1d "$d"*.xcodeproj   | head -1)"; break
				fi
			  done < <(ls -1d */ 2>/dev/null || true)
			fi
			
			[ -n "$Project_Path" ] || { echo "[ERR] 未找到 .xcworkspace 或 .xcodeproj"; exit 1; }
			
			base="${Project_Path##*/}"            # 去前缀路径
			Project_Kind="${base##*.}"            # xcworkspace / xcodeproj
			Project_Name="${base%.*}"             # 去后缀
			echo "[INFO] Project_Path=$Project_Path"
			echo "[INFO] Project_Kind=$Project_Kind"
			echo "[INFO] Project_Name=$Project_Name"
		
		# —— 在解析完 profile 的 Name/UUID/TEAMID/BUNDLEID 之后立刻兜底 —— 
		# 例如：NAME、UUID、TEAMID、BUNDLEID 都已从 $PLIST 取到
		: "${CPROVISIONING_PROFILE_NAME:=$NAME}"   # 修复 set -u 下未赋值就使用的问题
		: "${DESTINATION:=generic/platform=iOS}"    # 如果前面没判定平台，给个默认
		
		echo "[ENV] CPROVISIONING_PROFILE_NAME=$CPROVISIONING_PROFILE_NAME"
		echo "[ENV] DESTINATION=$DESTINATION"
		
		# —— 一次性抓 list 输出 —— 
		echo "[LIST] run xcodebuild -list from $Project_Kind"
		if [[ "$Project_Kind" == "xcworkspace" ]]; then
		  RAW_LIST=$(xcodebuild -list -workspace "$Project_Path" 2>/dev/null || true)
		else
		  RAW_LIST=$(xcodebuild -list -project   "$Project_Path" 2>/dev/null || true)
		fi
		
		echo "[LIST] raw >>>"
		printf '%s\n' "$RAW_LIST" | sed -e 's/^/  | /'
		echo "[LIST] <<< end"
		
		# —— 解析 Schemes（忽略前导空格、去回车、去掉空行），再过滤 *Tests —— 
		SCHEMES=$(
		  printf '%s\n' "$RAW_LIST" \
		  | tr -d '\r' \
		  | awk '
			  /^[[:space:]]*Schemes:/ {inlist=1; next}
			  inlist && /^[[:space:]]*$/ {inlist=0}
			  inlist { sub(/^[[:space:]]+/, "", $0); print }
			'
		)
		echo "[LIST] parsed schemes:"
		printf '  - %s\n' $SCHEMES
		
		SCHEME_CAND=()
		while IFS= read -r s; do
		  s="$(echo "$s" | xargs)"
		  [[ -n "$s" ]] && SCHEME_CAND+=("$s")
		done < <(printf '%s\n' "$SCHEMES" | grep -v 'Tests$' || true)
		
		# 若全被过滤掉，则回退到原始列表
		if [[ ${#SCHEME_CAND[@]} -eq 0 ]]; then
		  while IFS= read -r s; do
			s="$(echo "$s" | xargs)"
			[[ -n "$s" ]] && SCHEME_CAND+=("$s")
		  done < <(printf '%s\n' "$SCHEMES")
		fi
		
		echo "[LIST] scheme candidates:"
		if [[ ${#SCHEME_CAND[@]} -gt 0 ]]; then
		  printf '  - %s\n' "${SCHEME_CAND[@]}"
		else
		  echo "  - <none>"
		fi
		[ ${#SCHEME_CAND[@]} -gt 0 ] || { echo "[ERR] 未找到任何 Scheme"; exit 1; }
		
		# 优先与工程同名，否则取第一个
		auto_scheme="${SCHEME_CAND[0]}"
		for s in "${SCHEME_CAND[@]}"; do
		  if [[ "$s" == "$Project_Name" ]]; then auto_scheme="$s"; break; fi
		done
		: "${project_scheme:=$auto_scheme}"
		echo "[INFO] project_scheme=$project_scheme"
		
		# —— 解析 Build Configurations（同一份 RAW_LIST） —— 
		CFGS=$(
		  printf '%s\n' "$RAW_LIST" \
		  | tr -d '\r' \
		  | awk '
			  /^[[:space:]]*Build Configurations:/ {inlist=1; next}
			  inlist && /^[[:space:]]*If no build configuration/ {inlist=0}
			  inlist { sub(/^[[:space:]]+/, "", $0); print }
			'
		)
		echo "[LIST] parsed configurations:"
		printf '%s\n' "$CFGS" | sed -e 's/^/  - /'
		
		CFG_CAND=()
		while IFS= read -r c; do
		  c="$(echo "$c" | xargs)"
		  [[ -n "$c" ]] && CFG_CAND+=("$c")
		done < <(printf '%s\n' "$CFGS")
		
		if [[ ${#CFG_CAND[@]} -eq 0 ]]; then
		  echo "[WARN] 未解析到 Build Configurations，回退到 Debug"
		  CFG_CAND=("Debug")
		fi
		auto_cfg="${CFG_CAND[0]}"
		for c in "${CFG_CAND[@]}"; do
		  if [[ "$c" == "Debug" ]]; then auto_cfg="$c"; break; fi
		done
		: "${Configuration:=$auto_cfg}"
		echo "[INFO] Configuration=$Configuration"
		
		#自动探测 DESTINATION
			declare -a SRC_OPTS=()
			if [[ "$Project_Kind" == "xcworkspace" ]]; then
			  project_workspace="$Project_Path"
			  SRC_OPTS=(-workspace "$project_workspace")
			else
			  project_proj="$Project_Path"
			  SRC_OPTS=(-project "$project_proj")
			fi
		
			echo "[AUTO] probing destinations for scheme: $project_scheme"
			RAW_DEST=$(xcodebuild "${SRC_OPTS[@]}" -scheme "$project_scheme" -showdestinations 2>/dev/null || true)
			
			echo "[AUTO] raw -showdestinations >>>"
			printf '%s\n' "$RAW_DEST" | sed -e 's/^/  | /'
			echo "[AUTO] <<< end"
			
			DESTINATION=""
			
			# 1) 先找“泛化真机”目的地（generic），按优先级 visionOS -> iOS -> macOS
			if printf '%s\n' "$RAW_DEST" | grep -Eq 'platform:[[:space:]]*visionOS([,} ]|$)'; then
			  DESTINATION="generic/platform=visionOS"
			elif printf '%s\n' "$RAW_DEST" | grep -Eq 'platform:[[:space:]]*iOS([,} ]|$)'; then
			  DESTINATION="generic/platform=iOS"
			elif printf '%s\n' "$RAW_DEST" | grep -Eq 'platform:[[:space:]]*macOS([,} ]|$)'; then
			  DESTINATION="generic/platform=macOS"
			fi
			
			# 2) 如果没有 generic，就挑一个带 id 的具体目的地（优先 visionOS 模拟器）
			if [ -z "$DESTINATION" ]; then
			  sim_id=$(printf '%s\n' "$RAW_DEST" \
						 | awk -F'[{},]' '/platform:[[:space:]]*visionOS Simulator/{
							  for(i=1;i<=NF;i++){
								if($i ~ /id:/){gsub(/^[[:space:]]*id:[[:space:]]*/,"",$i); print $i; exit}
							  }
						   }' | head -1)
			  if [ -n "$sim_id" ]; then
				DESTINATION="id=$sim_id"
			  fi
			fi
			
			# 3) 还没有的话，挑任意一个 id
			if [ -z "$DESTINATION" ]; then
			  any_id=$(printf '%s\n' "$RAW_DEST" \
						 | awk -F'[{},]' '/id:/{
							  for(i=1;i<=NF;i++){
								if($i ~ /id:/){gsub(/^[[:space:]]*id:[[:space:]]*/,"",$i); print $i; exit}
							  }
						   }' | head -1)
			  if [ -n "$any_id" ]; then
				DESTINATION="id=$any_id"
			  fi
			fi
			
			# 4) 最后兜底：用 profile 的平台提示；再不行就给 visionOS 作为最终兜底
			: "${DESTINATION:=${DESTINATION_HINT:-}}"
			: "${DESTINATION:=generic/platform=visionOS}"
			
			echo "[AUTO] using destination: $DESTINATION"
		
		
		
		# —— 这些变量若未定义，这里统一给兜底，避免 set -u 触发 ——
		echo "[INFO] WORKSPACE=$WORKSPACE"
		
		build_dir="${build_dir:-"${WORKSPACE:-$PWD}/build"}"
		export_path="${export_path:-"$HOME/project/build/${Project_Name}"}"
		archive_path="${archive_path:-"${build_dir}/${project_scheme}.xcarchive"}"
		exportOptionsPlist="${exportOptionsPlist:-"${build_dir}/${project_scheme}.plist"}"
		export DEVELOPMENT_TEAM="$TEAMID"
		
		# —— 写回 BuildVariable，供 post 阶段读取 ----
        cat > BuildVariable <<EOF
	    	project_scheme=${project_scheme}
			export_path=${export_path}
			build_dir=${build_dir}
			archive_path=${archive_path}
			exportOptionsPlist=${exportOptionsPlist}
EOF

		echo "==[DEBUG] wrote BuildVariable =="
		sed -n '1,200p' BuildVariable || true
		
		
		# —— 生成 exportOptionsPlist（用 profile 名称绑定） —— 
		mkdir -p "${build_dir}" "${export_path}"
		cat > "${exportOptionsPlist}" <<PL
		<?xml version="1.0" encoding="UTF-8"?>
		<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
		<plist version="1.0"><dict>
		  <key>signingStyle</key><string>manual</string>
		  <key>teamID</key><string>${TEAMID}</string>      
		  <key>method</key><string>$${METHOD}</string>
		  <key>signingCertificate</key><string>${CERT_KIND}</string>
		  <key>provisioningProfiles</key><dict>
			<key>${BUNDLEID}</key><string>${CPROVISIONING_PROFILE_NAME}</string>
		  </dict>
		  <key>stripSwiftSymbols</key><true/>
		  <key>compileBitcode</key><true/>
		</dict></plist>
PL
		
		# —— 选择 workspace / project 源参数 —— 
		
		SRC_OPTS=()
		if [[ "$Project_Kind" == "xcworkspace" ]]; then
		  project_workspace="$Project_Path"
		  SRC_OPTS=(-workspace "$project_workspace")
		else
		  project_proj="$Project_Path"
		  SRC_OPTS=(-project "$project_proj")
		fi
		

		
		# —— 构建 —— 
		echo " 构建 Archive "不签名
		xcodebuild \
		  "${SRC_OPTS[@]}" \
		  -scheme "$project_scheme" \
		  -configuration "$Configuration" \
		  clean archive \
		  -archivePath "$archive_path" \
		  -destination "$DESTINATION" \
		  CODE_SIGN_STYLE=Manual \
		  DEVELOPMENT_TEAM="$TEAMID" \
		 # CODE_SIGNING_ALLOWED=NO \
		  CODE_SIGN_IDENTITY="Apple Distribution" \
		  PRODUCT_BUNDLE_IDENTIFIER="$BUNDLEID" \
		  PROVISIONING_PROFILE_SPECIFIER="$CPROVISIONING_PROFILE_NAME" \
		  -allowProvisioningUpdates \
		  -allowProvisioningDeviceRegistration \
		  -UseModernBuildSystem=NO \
		  -quiet		
		
		
		
		echo " 导出 IPA"
		xcodebuild -exportArchive \
		  -archivePath "$archive_path" \
		  -exportOptionsPlist "$exportOptionsPlist" \
		  -exportPath "$export_path" \
		  -quiet
		
		echo "[BUILD] exported:"
		ls -lh "$export_path" || true
		'''
		  }
		
		 //  5) 在这个 stage 的 post 里收集产物（仍在 macOS 节点上）"	
		  post {
			always {
			  script {
			  withCredentials([sshUserPrivateKey(credentialsId: '137ssh',
                                   keyFileVariable: 'SSH_KEY',
                                   usernameVariable: 'SSH_USER')]) {
		sh '''#!/bin/bash
		# 更强的调试与兜底
		set -eE -o pipefail
		trap 'echo "[ERROR] line=$LINENO exit=$?"' ERR
		
		echo "========== [DEBUG] 环境与目录 =========="
		echo "[DEBUG] whoami=$(whoami)"
		echo "[DEBUG] PWD=$(pwd)"
		echo "[DEBUG] WORKSPACE=${WORKSPACE:-<unset>}"
		echo "[DEBUG] JOB_BASE_NAME=${JOB_BASE_NAME:-<unset>} BUILD_NUMBER=${BUILD_NUMBER:-<unset>}"
		echo "[DEBUG] 列表当前目录："
		ls -lah || true
		echo
		
		REMOTE="17.87.2.137"
		REMOTE_BASE="/Users/mdsadmin/Documents"
		RUN_DIR="${JOB_BASE_NAME}#${BUILD_NUMBER}"
		REMOTE_DIR="${REMOTE_BASE}/${RUN_DIR}"
		
		echo "========== [DEBUG] 尝试读取 BuildVariable =========="
		# 先关闭 -u，避免 source 时因为未定义变量而报错
		set +u
		if [ -f BuildVariable ]; then
		  echo "[DEBUG] BuildVariable 存在，内容如下："
		  sed -n '1,200p' BuildVariable || true
		  # shellcheck disable=SC1091
		  . BuildVariable
		else
		  echo "[WARN] BuildVariable 不存在：$PWD/BuildVariable"
		fi
		set -u
		echo
		
		# 兜底并打印变量
		export_path=${export_path:-}
		archive_path=${archive_path:-}
		project_scheme=${project_scheme:-app}
		
		echo "========== [DEBUG] 关键变量值 =========="
		echo "[DEBUG] export_path=${export_path}"
		echo "[DEBUG] archive_path=${archive_path}"
		echo "[DEBUG] project_scheme=${project_scheme}"
		echo
		
		echo "========== [DEBUG] 本地产物路径检查 =========="
		if [ -n "$export_path" ]; then
		  echo "[DEBUG] 列表 export_path：$export_path"
		  ls -lah "$export_path" || true
		  echo "[DEBUG] 查找 IPA："
		  shopt -s nullglob
	  	  found_any=false
		  for f in "$export_path"/*.ipa; do
		    found_any=true
		    # 兼容 macOS 与 Linux 的 stat
		    size=$(stat -f%z "$f" 2>/dev/null || stat -c%s "$f" 2>/dev/null || echo 0)
		    sha=$(shasum -a 1 "$f" 2>/dev/null | awk '{print $1}')
		    echo "[DEBUG] file=$f  size=${size} bytes  sha1=${sha}"
		  done
		  shopt -u nullglob
		  if [ "$found_any" = false ]; then
		    echo "[DEBUG] 没有匹配到 *.ipa"
		  fi
 		else
		  echo "[WARN] export_path 为空"
		fi
		
		if [ -n "$archive_path" ]; then
		  echo "[DEBUG] 检查 archive_path 目录：$archive_path"
		  if [ -d "$archive_path" ]; then
			du -sh "$archive_path" || true
			echo "[DEBUG] 列表部分内容："
			ls -lah "$archive_path" | head -50 || true
		  else
			echo "[WARN] archive_path 不存在目录：$archive_path"
		  fi
		else
		  echo "[WARN] archive_path 为空"
		fi
		echo
		
		echo "========== [DEBUG] 远端连通性自检 =========="
		ssh -i "$SSH_KEY" -o BatchMode=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
		  "$SSH_USER@$REMOTE" 'echo "[REMOTE] ok from $(hostname)"; uname -a; sw_vers 2>/dev/null || true' || {
		  echo "[ERROR] SSH 直连失败（密钥/网络/账号）"
		  exit 2
		}
		echo
		
		echo "========== [STEP] 创建远端目录 =========="
		echo "[REMOTE] mkdir -p ${REMOTE_DIR}"
		ssh -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
		  "$SSH_USER@$REMOTE" "mkdir -p \"${REMOTE_DIR}\""
		echo
		
		echo "========== [STEP] 传 IPA =========="
		if [ -n "$export_path" ] && ls "$export_path"/*.ipa >/dev/null 2>&1; then
		  echo "[UPLOAD] ipa -> ${REMOTE}:${REMOTE_DIR}"
		  scp -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			  "$export_path"/*.ipa \
			  "$SSH_USER@$REMOTE:${REMOTE_DIR}/"
		else
		  echo "[UPLOAD] no ipa found under ${export_path}"
		fi
		echo
		
		echo "========== [STEP] 传 .xcarchive（rsync） =========="
		if [ -n "$archive_path" ] && [ -d "$archive_path" ]; then
		  echo "[UPLOAD] xcarchive -> ${REMOTE}:${REMOTE_DIR}/${project_scheme}.xcarchive/"
		  rsync -a \
			-e "ssh -i $SSH_KEY -o IdentitiesOnly=yes -o StrictHostKeyChecking=no" \
			"$archive_path"/ \
			"$SSH_USER@$REMOTE:${REMOTE_DIR}/${project_scheme}.xcarchive/"
		else
		  echo "[UPLOAD] no xcarchive dir at ${archive_path}"
		fi
		echo
		
		echo "========== [STEP] 附带上传 BuildVariable =========="
		if [ -f BuildVariable ]; then
		  scp -i "$SSH_KEY" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no \
			BuildVariable "$SSH_USER@$REMOTE:${REMOTE_DIR}/" || true
		else
		  echo "[INFO] BuildVariable 不存在，跳过上传"
		fi
		echo
		
		echo "[DONE] artifacts uploaded to ${REMOTE}:${REMOTE_DIR}"
		'''
		}
			  }
			}
		  }
		}
      }
  
  
  
  post {
	always {
	  script {
		try {
		  timeout(time: 2, unit: 'MINUTES') {
			node('macmain') {                         // ← 一定要进到有 kubectl 的节点
			  withKubeConfig([credentialsId: env.KCFG_ID]) {
				sh """
				  set -xe
				  kubectl -n ci delete pod macos-build-${env.BUILD_NODE} --ignore-not-found
				  kubectl -n ci delete secret jenkins-macos-${env.BUILD_NODE} --ignore-not-found
				"""
			  }
			  
			  // 再删 Jenkins 节点
			  withCredentials([usernameColonPassword(credentialsId: 'jenkins-api', variable: 'JAUTH')]) {
				  sh """#!/bin/bash
				set -euo pipefail
				JURL='${env.JENKINS_URL}'
				NODE='${env.BUILD_NODE}'
				
				CRUMB=\$(curl -fsS -u "\$JAUTH" "\$JURL/crumbIssuer/api/json" \
						| sed -n 's/.*"crumb"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/p')
				
				cat > .cleanup.groovy <<G
				import jenkins.model.Jenkins
				def name = "${env.BUILD_NODE}"   // ← 直接写入
				def j = Jenkins.get()
				def n = j.getNode(name)
				if (n != null) {
				  try { n.toComputer()?.doDoDisconnect("build finished; cleanup") } catch (ignored) {}
				  j.removeNode(n)
				  println "REMOVED " + name
				} else {
				  println "NOT_FOUND " + name
				}
G
				
				curl -fsS -u "\$JAUTH" -H "Jenkins-Crumb: \$CRUMB" \
				  --data-urlencode script@.cleanup.groovy \
				  "\$JURL/scriptText" | sed -n '1,80p'
				""" 
				}
			}
		  }
		} catch (e) {
		  echo "cleanup failed: ${e}"
		}
	  }
	}
  }
}
